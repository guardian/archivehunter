# This is the main configuration file for the application.
# ~~~~~

# Secret key
# ~~~~~
# The secret key is used to secure cryptographics functions.
# If you deploy your application to several instances be sure to use the same key!
application.secret="%APPLICATION_SECRET%"

# The application languages
# ~~~~~
application.langs="en"

externalData {
  awsRegion="eu-west-1"
  scanTargets="***REMOVED***"
  //ddbHost="localhost"
  ddbHost="dynamodb.eu-west-1.amazonaws.com"
  //if using development credentials on local machine, set this to the AWS CLI profile that contains your credentials.
  //if not set, defaults to the string "default"
  awsProfile="multimedia"
  indexName = "archivehunter"
  jobTable="archivehunter-CODE-JobHistoryTable-ZXN8IMG6VZ0H"
}

scanner {
  masterSchedule = 300 #in seconds
}

proxies {
  tableName = "archivehunter-CODE-ProxyLocationTable-1PVXV6DCH5UAE"
  ecsTaskDefinitionName = "arn:aws:ecs:eu-west-1:855023211239:task-definition/archivehunter-CODE-ProxyingTaskDefinition-1V2CUQ7UWAVB2:1"
  taskContainerName = "multimedia-archivehunterProxy-CODE"
  appServerUrl = "http://localhost:9000"
}

ecs {
  cluster = "multimedia-archivehunter-CODE"
  subnets = "subnet-09f78d7f"
}

elasticsearch {
  hostname = "localhost"
  port = 9200
  ssl = false
}

play.filters {

  # Enabled filters are run automatically against Play.
  # CSRFFilter, AllowedHostFilters, and SecurityHeadersFilters are enabled by default.

  hosts {
    allowed = [".elb.amazonaws.com","localhost:9000"]
  }

  # Disabled filters remove elements from the enabled list.
  disabled += play.filters.headers.SecurityHeadersFilter #temporarily disabled, pending testing in the frontend
  disabled += play.filters.hosts.AllowedHostsFilter #at present, enabling this breaks the tests
  disabled += play.filters.csrf.CSRFFilter #temporarily disabled until CSRF implemented in the frontend
}

akka.actor {
  provider = "cluster"

  serializers {
    akka-cluster-client = "akka.cluster.client.protobuf.ClusterClientMessageSerializer"
    akka-singleton = "akka.cluster.singleton.protobuf.ClusterSingletonMessageSerializer"
  }
  serialization-bindings {
    "akka.cluster.client.ClusterClientMessage" = akka-cluster-client
    "akka.cluster.singleton.ClusterSingletonMessage" = akka-singleton
  }
  serialization-identifiers {
    "akka.cluster.client.protobuf.ClusterClientMessageSerializer" = 15
    "akka.cluster.singleton.protobuf.ClusterSingletonMessageSerializer" = 14
  }
}

akka.remote {
  log-remote-lifecycle-events = off
  netty.tcp {
    hostname = "localhost"
    port = 2552
  }
}

akka.cluster {
  seed-nodes = ["akka.tcp://application@localhost:2552"]
}

akka.discovery {
  # Set the following in your application.conf if you want to use this discovery mechanism:
  # method = aws-api-ec2-tag-based

  aws-api-ec2-tag-based {

    class = akka.discovery.awsapi.ec2.Ec2TagBasedSimpleServiceDiscovery

    tag-key = "service"

    # filters have to be in key=value format, separated by semi-colon
    filters = ""

    # If you want multiple akka nodes (i.e. JVMs) per EC2 instance, set the following
    # to the list of Akka Management port numbers
    ports = []

  }

  # Set the following in your application.conf if you want to use this discovery mechanism:
  # method = aws-api-ecs

  aws-api-ecs {

    class = akka.discovery.awsapi.ecs.EcsSimpleServiceDiscovery

    cluster = "default"

  }

  # Set the gfollowing in your application.conf if you want to use this discovery mechanism:
  #method = kubernetes-api

  kubernetes-api {
    pod-namespace = "default" // in which namespace cluster is running
    pod-namespace = ${?K8S_NAMESPACE}
    pod-label-selector = "app=akka-simple-cluster" // selector - hot to find other cluster nodes
    pod-label-selector = ${?K8S_SELECTOR}
    pod-port-name = "management" // name of cluster management port
    pod-port-name = ${?K8S_MANAGEMENT_PORT}
  }

  method = ${?DISCOVERY_METHOD}
}