# This is the main configuration file for the application.
# ~~~~~

# Secret key
# ~~~~~
# The secret key is used to secure cryptographics functions.
# If you deploy your application to several instances be sure to use the same key!
application.secret="%APPLICATION_SECRET%"

# The application languages
# ~~~~~
application.langs="en"

externalData {
  awsRegion="eu-west-1"
  scanTargets="scanTargetsTable"
  jobTable="jobHistoryTable"
  //ddbHost="localhost"
  ddbHost="dynamodb.eu-west-1.amazonaws.com"
  indexName = "archivehunter"

  awsProfile="multimedia"
}

scanner {
  masterSchedule = 300 #in seconds
}

auth {
  panDomainBucket = "panda-bucket"
  deployedUrl = "https://archivehunter.local.dev-gutools.co.uk"
  domain = "local.dev-gutools.co.uk"
  userProfileTable = "***REMOVED***"
}

proxies {
  tableName = "tableName"
  ecsTaskDefinitionName = "ecsTaskArn"
  #this should match the container name in ProxyingTaskDefinition
  taskContainerName = "multimedia-archivehunterProxy-CODE"
  appServerUrl = "http://localhost"

  completionNotification = "topicArn"
  errorNotification = "topicArn"
  warningNotification = "topicArn"

  transcodingRole = "topicArn"

  notificationsQueue = "queueUrl"
  videoPresetId = "1387374611767-d52fja"
  audioPresetId = "1351620000001-300040"
}

ecs {
  cluster = "ecs-cluster-name"
  subnets = "ecs-allowed-subnets"
}

elasticsearch {
  hostname = "localhost"
  port = 9200
  ssl = false
}

play.filters {

  # Enabled filters are run automatically against Play.
  # CSRFFilter, AllowedHostFilters, and SecurityHeadersFilters are enabled by default.

  hosts {
    allowed = [".elb.amazonaws.com","localhost:9000"]
  }

  # Disabled filters remove elements from the enabled list.
  disabled += play.filters.headers.SecurityHeadersFilter #temporarily disabled, pending testing in the frontend
  disabled += play.filters.hosts.AllowedHostsFilter #at present, enabling this breaks the tests
  disabled += play.filters.csrf.CSRFFilter #temporarily disabled until CSRF implemented in the frontend
}

akka.actor {
  provider = "cluster"

  serializers {
    akka-cluster-client = "akka.cluster.client.protobuf.ClusterClientMessageSerializer"
    akka-singleton = "akka.cluster.singleton.protobuf.ClusterSingletonMessageSerializer"
  }
  serialization-bindings {
    "akka.cluster.client.ClusterClientMessage" = akka-cluster-client
    "akka.cluster.singleton.ClusterSingletonMessage" = akka-singleton
  }
  serialization-identifiers {
    "akka.cluster.client.protobuf.ClusterClientMessageSerializer" = 15
    "akka.cluster.singleton.protobuf.ClusterSingletonMessageSerializer" = 14
  }
}

akka.remote {
  log-remote-lifecycle-events = off
  netty.tcp {
    hostname = "localhost"
    port = 2552
  }
}

akka.cluster {
  seed-nodes = ["akka.tcp://application@localhost:2552"]
  auto-down-unreachable-after = 30s //important for EC2
}

akka.io.dns.resolver = async-dns

akka.discovery {
  method = akka-dns
  # Set the following in your application.conf if you want to use this discovery mechanism:
  # method = aws-api-ec2-tag-based


  aws-api-ec2-tag-based {

    class = akka.discovery.awsapi.ec2.Ec2TagBasedSimpleServiceDiscovery

    tag-key = "service"

    # filters have to be in key=value format, separated by semi-colon
    filters = ""

    # If you want multiple akka nodes (i.e. JVMs) per EC2 instance, set the following
    # to the list of Akka Management port numbers
    ports = []

  }

  # Set the following in your application.conf if you want to use this discovery mechanism:
  # method = aws-api-ecs

  aws-api-ecs {

    class = akka.discovery.awsapi.ecs.EcsSimpleServiceDiscovery

    cluster = "default"

  }

  # Set the gfollowing in your application.conf if you want to use this discovery mechanism:
  #method = kubernetes-api

  kubernetes-api {
    pod-namespace = "default" // in which namespace cluster is running
    pod-namespace = ${?K8S_NAMESPACE}
    pod-label-selector = "app=akka-simple-cluster" // selector - hot to find other cluster nodes
    pod-label-selector = ${?K8S_SELECTOR}
    pod-port-name = "management" // name of cluster management port
    pod-port-name = ${?K8S_MANAGEMENT_PORT}
  }

  method = ${?DISCOVERY_METHOD}
}