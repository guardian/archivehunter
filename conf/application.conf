# This is the main configuration file for the application.
# ~~~~~

# Secret key
# ~~~~~
# The secret key is used to secure cryptographics functions.
# If you deploy your application to several instances be sure to use the same key!
application.secret="%APPLICATION_SECRET%"

# The application languages
# ~~~~~
application.langs="en"

# Global object class
# ~~~~~
# Define the Global object class for this application.
# Default to Global in the root package.
# application.global=Global

# Router
# ~~~~~
# Define the Router object to use for this application.
# This router will be looked up first when the application is starting up,
# so make sure this is the entry point.
# Furthermore, it's assumed your route file is named properly.
# So for an application router like `my.application.Router`,
# you may need to define a router file `conf/my.application.routes`.
# Default to Routes in the root package (and conf/routes)
# application.router=my.application.Routes

# Database configuration
# ~~~~~
# You can declare as many datasources as you want.
# By convention, the default datasource is named `default`
#
# db.default.driver=org.h2.Driver
# db.default.url="jdbc:h2:mem:play"
# db.default.user=sa
# db.default.password=""

# Evolutions
# ~~~~~
# You can disable evolutions if needed
# evolutionplugin=disabled

# Logger
# ~~~~~
# You can also configure logback (http://logback.qos.ch/),
# by providing an application-logger.xml file in the conf directory.

# Root logger:
logger.root=ERROR

# Logger used by the framework:
logger.play=INFO

# Logger provided to your application:
logger.application=DEBUG

externalData {
  awsRegion="eu-west-1"
  scanTargets="archivehunter-CODE-ScanTargetsTable-1D2X41LOAMMXR"
  //ddbHost="localhost"
  ddbHost="dynamodb.eu-west-1.amazonaws.com"
  //if using development credentials on local machine, set this
  awsProfile="multimedia"
}

play.filters {

  # Enabled filters are run automatically against Play.
  # CSRFFilter, AllowedHostFilters, and SecurityHeadersFilters are enabled by default.

  hosts {
    allowed = [".elb.amazonaws.com","localhost:9000"]
  }

  # Disabled filters remove elements from the enabled list.
  disabled += play.filters.headers.SecurityHeadersFilter #temporarily disabled, pending testing in the frontend
  disabled += play.filters.hosts.AllowedHostsFilter #at present, enabling this breaks the tests
  disabled += play.filters.csrf.CSRFFilter #temporarily disabled until CSRF implemented in the frontend
}

akka.actor {
  provider = "cluster"
}

akka.cluster {
  seed-nodes = []
}

akka.discovery {
  # Set the following in your application.conf if you want to use this discovery mechanism:
  # method = aws-api-ec2-tag-based

  aws-api-ec2-tag-based {

    class = akka.discovery.awsapi.ec2.Ec2TagBasedSimpleServiceDiscovery

    tag-key = "service"

    # filters have to be in key=value format, separated by semi-colon
    filters = ""

    # If you want multiple akka nodes (i.e. JVMs) per EC2 instance, set the following
    # to the list of Akka Management port numbers
    ports = []

  }

  # Set the following in your application.conf if you want to use this discovery mechanism:
  # method = aws-api-ecs

  aws-api-ecs {

    class = akka.discovery.awsapi.ecs.EcsSimpleServiceDiscovery

    cluster = "default"

  }

  # Set the gfollowing in your application.conf if you want to use this discovery mechanism:
  #method = kubernetes-api

  kubernetes-api {
    pod-namespace = "default" // in which namespace cluster is running
    pod-namespace = ${?K8S_NAMESPACE}
    pod-label-selector = "app=akka-simple-cluster" // selector - hot to find other cluster nodes
    pod-label-selector = ${?K8S_SELECTOR}
    pod-port-name = "management" // name of cluster management port
    pod-port-name = ${?K8S_MANAGEMENT_PORT}
  }

  method = ${?DISCOVERY_METHOD}
}